<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stable Diffusion Design Assistant</title>
  <style>
    body {
      font: 1em sans-serif;
    }

    h6 {
      color: red;
    }

    h5 {
      color: blue;
    }

    input {
      width: 100%;
      height: 40px;
    }

    .radio {
      width: 20px;
      height: 20px;
    }

    .checkbox {
      width: 20px;
      height: 20px;
    }

    label {
      display: flex;
      align-items: center;
    }

    label input[type="checkbox"] {
      width: 16px;
      height: 16px;
      margin-right: 5px;
    }

    label span {
      line-height: 1.2;
    }

    .size {
      width: 100%;
    }

    table {
      width: 100%;
      text-align: center;
      vertical-align: middle;
    }

    .sizeSliders td,
    table th {
      width: 50%;
      text-align: center;
      vertical-align: middle;
    }

    .stylesRadio td,
    table th {
      width: 33%;
      text-align: left;
      vertical-align: left;
    }

    #mask_only {
      width: 16px;
      height: 16px;
      margin-right: 5px;
    }

    .image2vectors2imageTable {
      font-size: x-small;
    }

    img {
      width: 100%;
    }

    .row {
      display: flex;
      flex-direction: row;
      justify-content: space-evenly;
    }

    progress {
      width: 100%;
    }
  </style>
</head>

<body>
  <table>
    <tr>
      <th>
        <p>Hosting URL:</p>
      </th>
      <th>
        <p>API Key:</p>
      </th>
    </tr>
    <tr>
      <td><input id="url" type="text" placeholder="Enter a Stable Diffusion Hosting URL" /></td>
      <td><input id="api_key" type="password" placeholder="Enter the API key for Server if needed" /></td>
    </tr>
  </table>


  <div class="row">
    <input type="button" id="connect2local" value="Connect to&#13;&#10;Local Server"
      onclick="document.getElementById('url').value='http://localhost:7860';checkAvailibility()" />
    <input type="button" id="connect2offical" value="Connect to&#13;&#10;Demo Server"
      onclick="document.getElementById('url').value='https://sd.tecky.ai';checkAvailibility()" />
  </div>
  <h6 id="server_log"></h6>
  <h5 id="connection_status"></h5>
  <p>Prompt:</p>
  <input id="prompt" type="text" placeholder="Enter a prompt" />
  <div class="row">
    <label><input type="checkbox" class="checkbox" id="keep_generating_checkbox"><span>Keep Generating</span></label>
    <input id="seed" type="text" style="width: 45%;" placeholder="Seed" inputmode="numeric">
  </div>
  <table class="sizeSliders">
    <tr>
      <th>Width</th>
      <th>Height</th>
    </tr>
    <tr>
      <td><input type="text" class="size" id="width" value="768"></td>
      <td><input type="text" class="size" id="height" value="768"></td>
    </tr>
    <tr>
      <td><input type="range" class="size" id="width_slider" min="512" max="960" value="768" step="64"
          oninput="width_slider.value=parseInt(width_slider.value);document.getElementById('width').value=width_slider.value">
      </td>
      <td><input type="range" class="size" id="height_slider" min="512" max="960" value="768" step="64"
          oninput="height_slider.value=parseInt(height_slider.value);document.getElementById('height').value=height_slider.value">
      </td>
    </tr>
  </table>
  <table class="stylesRadio">
    <tr>
      <th></th>
      <th></th>
      <th></th>
    </tr>
    <tr>
      <td><input type="radio" class="radio" name="style" value="default" checked><label for="style">Default</label></td>
      <td><input type="radio" class="radio" name="style" value="photo"><label for="style">Photo</label></td>
      <td><input type="radio" class="radio" name="style" value="icon"><label for="style">Icon</label></td>
    </tr>
    <tr>
      <td><input type="radio" class="radio" name="style" value="sticker"><label for="style">Sticker</label></td>
      <td><input type="radio" class="radio" name="style" value="anime"><label for="style">Anime</label></td>
      <td><input type="radio" class="radio" name="style" value="studio"><label for="style">Studio</label></td>
    </tr>
  </table>
  <div class="row">
    <input type="button" id="txt2img" disabled value="Text 2 Image" />
  </div>
  <div class="row">
    <input type="button" id="auto_mask" disabled value="Auto&#13;&#10;Background Removal" />
    <input type="button" id="prompt_mask" disabled value="Prompt&#13;&#10;Background Removal" />
  </div>
  <table class="image2vectors2imageTable">
    <tr>
      <th></th>
      <th></th>
    </tr>
    <tr>
      <td><label id="canny_high_threshold_label" for="canny_high_threshold_slider">High Threshold: 200</label></td>
      <td><label><input type="checkbox" class="checkbox" id="mask_only"><span>Mask Only</span></label></td>
    </tr>
    <tr>
      <td><input type="range" id="canny_high_threshold_slider" min="1" max="255" value="200" step="1"></td>
      <td></td>
    </tr>
    <tr>
      <td><label id="canny_low_threshold_label" for="canny_low_threshold_label">Low Threshold: 100</label></td>
      <td><label id="vectors_guidance_label" for="vectors_guidance_slider">Vectors Guidance: Normal</label></td>
    </tr>
    <tr>
      <td><input type="range" id="canny_low_threshold_slider" min="1" max="255" value="100" step="1"></td>
      <td>
        <input type="range" id="vectors_guidance_slider" min="0" max="2" value="1" step="0.25"
          list="vectors_guidance_data">
        <datalist id="vectors_guidance_data">
          <option value="0" label="None">
          <option value="0.5" label="Free">
          <option value="1" label="Normal">
          <option value="1.5" label="Details">
          <option value="2" label="Same">
        </datalist>
      </td>
    </tr>
  </table>
  <div class="row">
    <input type="button" id="image_2_vectors" disabled value="Image 2 Vectors" />
    <input type="button" id="vectors_2_image" disabled value="Render Sketch" />
  </div>
  <div class="row">
    <input type="button" id="find_items" disabled value="Find Items" />
  </div>
  <progress id="progress" value="0" max="1"></progress>
</body>

</html>
<script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simplify-js@1.2.4/simplify.min.js"></script>
<script>
  const TickPeriod = 1000;
  const urlInput = document.getElementById('url');
  const apikeyInput = document.getElementById('api_key');
  const txt2imgButton = document.getElementById('txt2img');
  const renderSketchButton = document.getElementById('vectors_2_image');
  const autoMaskButton = document.getElementById('auto_mask');
  const promptMaskButton = document.getElementById('prompt_mask');
  const image_2_vectorsButton = document.getElementById('image_2_vectors');
  const findItemsButton = document.getElementById('find_items');
  const serverLogLabel = document.getElementById('server_log');
  const connectionStatusLabel = document.getElementById('connection_status');
  const keepGeneratingCheckbox = document.getElementById('keep_generating_checkbox');
  const seedInput = document.getElementById('seed');
  let realProgressUpdateTime = TickPeriod * 10;
  let realProgressInterval = null;
  let fakeProgressUpdateTime = TickPeriod * 1;
  let fakeProgressInterval = null;
  let sdServerAvailable = false;
  let autoMaskAvailable = false;
  let figmaAvailable = false;
  let promptMaskAvailable = false;
  let controlNetAvailable = false;
  let generatingImage = false;
  let selected_nodes_count = 0;
  const checkAvailibilityDebouncedHandleInputValueChange = debounce(checkAvailibility, TickPeriod * 0.5);
  const throttledGetProgress = runEvery(getProgress, TickPeriod * 10);
  urlInput.addEventListener('input', checkAvailibilityDebouncedHandleInputValueChange);
  apikeyInput.addEventListener('input', (e) => {
    let api_key = e.target.value;
    parent.postMessage({ pluginMessage: { type: "update_api_key", api_key: api_key } }, "*");
  });
  document.getElementById('txt2img').onclick = (e) => {
    txt2img();
  }
  document.getElementById('seed').oninput = (e) => {
    let seed = e.target.value;
    if (seed !== "") {
      keepGeneratingCheckbox.checked = false;
    }
  }
  document.querySelector("#image_2_vectors").addEventListener("click", (e) => {
    parent.postMessage({ pluginMessage: { type: 'get_selected_image', original_task: "image_2_vectors" } }, '*')
  });
  document.querySelector("#auto_mask").addEventListener("click", (e) => {
    parent.postMessage({ pluginMessage: { type: 'get_selected_image', original_task: "auto_mask" } }, '*')
  });
  document.querySelector("#prompt_mask").addEventListener("click", (e) => {
    parent.postMessage({ pluginMessage: { type: 'get_selected_image', original_task: "prompt_mask" } }, '*')
  });
  document.querySelector("#vectors_2_image").addEventListener("click", (e) => {
    vectors_2_image();
  });
  document.querySelector("#find_items").addEventListener("click", (e) => {
    parent.postMessage({ pluginMessage: { type: 'find_items', original_task: "find_items" } }, '*')
  });
  document.querySelector("#vectors_guidance_slider").addEventListener("input", (e) => {
    switch (e.target.value) {
      case "0":
        document.querySelector("#vectors_guidance_label").textContent = `Vectors Guidance: None`;
        break;
      case "0.5":
        document.querySelector("#vectors_guidance_label").textContent = `Vectors Guidance: Free`;
        break;
      case "1":
        document.querySelector("#vectors_guidance_label").textContent = `Vectors Guidance: Normal`;
        break;
      case "1.5":
        document.querySelector("#vectors_guidance_label").textContent = `Vectors Guidance: Details`;
        break;
      case "2":
        document.querySelector("#vectors_guidance_label").textContent = `Vectors Guidance: Same`;
        break;
    }
  });
  document.querySelector("#canny_high_threshold_slider").addEventListener("input", (e) => {
    document.querySelector("#canny_high_threshold_label").textContent = `High Threshold: ${e.target.value}`;
  });
  document.querySelector("#canny_low_threshold_slider").addEventListener("input", (e) => {
    document.querySelector("#canny_low_threshold_label").textContent = `Low Threshold: ${e.target.value}`;
  });

  window.addEventListener('message', event => {
    if (event.data && event.data.pluginMessage.type === 'api_results') {
      on_api_results(event.data.pluginMessage.original_task, event.data.pluginMessage.data);
    }
    if (event.data && event.data.pluginMessage.type === 'done') {
      on_done(event.data.pluginMessage.original_task);
    }
    if (event.data && event.data.pluginMessage.type === 'image_selected') {
      on_selected_image(event.data.pluginMessage.original_task, event.data.pluginMessage.data);
    }
    if (event.data && event.data.pluginMessage.type === 'sync_img2img_ui') {
      setUiAvailiability(event.data.pluginMessage.selected_nodes_count);
    }
    if (event.data && event.data.pluginMessage.type === 'on_initialized') {
      urlInput.value = event.data.pluginMessage.url;
      apikeyInput.value = event.data.pluginMessage.api_key;
      checkAvailibility();
      selected_nodes_count = event.data.pluginMessage.selected_nodes_count;
    }
    if (event.data && event.data.pluginMessage.type === 'btoa') {
      checkAvailibility();
      selected_nodes_count = event.data.pluginMessage.selected_nodes_count;
    }
  });

  window.addEventListener("keydown", function (event) {
    if (event.key === "Escape") {
      parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*')
    }
    if (event.key === "Enter") {
      vectors_2_image()
    }
    if (event.shiftKey && event.key === "Enter") {
      txt2img()
    }
  });

  async function on_done(original_task) {
    txt2imgButton.disabled = false;
    renderSketchButton.disabled = false;
    generatingImage = false;
    clearInterval(realProgressInterval);
    clearInterval(fakeProgressInterval);
    document.getElementById('progress').value = 1;
    switch (original_task) {
      case "txt2img":
        document.getElementById('progress').value = 1;
        if (keepGeneratingCheckbox.checked) txt2img();
        break;
      case "vectors_2_image":
        document.getElementById('progress').value = 1;
        if (keepGeneratingCheckbox.checked) vectors_2_image();
        break;
    }
  }
  async function on_api_results(original_task, data) {
    let byte_array = null;
    switch (original_task) {
      case "prompt_mask":
      case "txt2img":
      case "auto_mask":
      case "vectors_2_image":
        byte_array = _base64ToUint8Array(data);
        parent.postMessage({ pluginMessage: { type: 'create_image_node', original_task, byte_array } }, '*')
        break;
      case "get_canny":
        image_2_vectors(data);
        break;
    }
  }
  async function on_selected_image(original_task, data) {
    switch (original_task) {
      case "image_2_vectors":
        get_canny(data, original_task);
        break;
      case "auto_mask":
      case "prompt_mask":
      case "vectors_2_image":
        image2image(data, original_task);
        break;
    }
  }
  function image2image(data, original_task) {
    var base64 = btoa(new Uint8Array(data).reduce((data, byte) => data + String.fromCharCode(byte), ''),);
    const style = getSelectedStyle()
    const textbox_prompt = document.getElementById('prompt');
    const width_input = document.getElementById('width');
    const height_input = document.getElementById('height');
    const url = document.getElementById('url').value;
    const vectors_guidance = document.getElementById('vectors_guidance_slider').value;
    const mask_only = document.getElementById('mask_only').checked;

    let seed = getSeed();
    let prompt = textbox_prompt.value;
    let width = width_input.value;
    let height = height_input.value;
    const pluginMessage = { type: original_task, imageUrl: base64, prompt, width, height, style, url, vectors_guidance, mask_only, seed }
    parent.postMessage({ pluginMessage }, '*')
  }
  async function get_canny(data, original_task) {
    var base64 = btoa(new Uint8Array(data).reduce((data, byte) => data + String.fromCharCode(byte), ''),);
    const url = urlInput.value;
    const canny_low_threshold = document.getElementById('canny_low_threshold_slider').value;
    const canny_high_threshold = document.getElementById('canny_high_threshold_slider').value;
    const pluginMessage = { type: "canny", original_task, imageUrl: base64, url, canny_low_threshold, canny_high_threshold }
    parent.postMessage({ pluginMessage }, '*')
  }
  function image_2_vectors(base64String) {
    let url = `data:image/png;base64,${base64String}`
    const img = document.createElement('img');
    img.src = url;
    ImageTracer.imageToSVG(url, function (svgstr) {
      const width_input = document.getElementById('width');
      const height_input = document.getElementById('height');
      let width = width_input.value;
      let height = height_input.value;
      parent.postMessage({ pluginMessage: { type: 'create_node_from_svg', svgstr, width, height } }, '*')
    }, "posterized1");
  }
  async function txt2img() {
    if (txt2imgButton.disabled) { return; }
    if (await isQueueing()) return;
    const style = getSelectedStyle()
    const textbox_prompt = document.getElementById('prompt');
    const width_input = document.getElementById('width');
    const height_input = document.getElementById('height');
    const url = document.getElementById('url').value;
    let prompt = textbox_prompt.value;
    let width = width_input.value;
    let height = height_input.value;
    let seed = getSeed();
    parent.postMessage({ pluginMessage: { type: 'txt2img', prompt, width, height, style, url, seed } }, '*');
    generatingImage = true;
    setUiAvailiability();
    document.getElementById('progress').value = 0;
    realProgressInterval = setInterval(setProgress, realProgressUpdateTime);
    fakeProgressInterval = setInterval(fakeProgress, fakeProgressUpdateTime);
  }
  async function vectors_2_image() {
    if (renderSketchButton.disabled) { return };
    if (await isQueueing()) { return };
    parent.postMessage({ pluginMessage: { type: 'get_selected_image', original_task: "vectors_2_image" } }, '*');
    generatingImage = true;
    setUiAvailiability();
    document.getElementById('progress').value = 0;
    realProgressInterval = setInterval(setProgress, realProgressUpdateTime);
    fakeProgressInterval = setInterval(fakeProgress, fakeProgressUpdateTime);
  }
  function _base64ToUint8Array(base64) {
    var binary_string = window.atob(base64);
    var len = binary_string.length;
    var bytes = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
      bytes[i] = binary_string.charCodeAt(i);
    }
    return new Uint8Array(bytes.buffer);
  }
  function getSelectedStyle() {
    return document.querySelector('input[name="style"]:checked').value;
  }
  async function isQueueing() {
    let progressData = await throttledGetProgress();
    if (progressData.state.job_count > 0) {
      serverLogLabel.innerHTML = "";
      serverLogLabel.innerHTML += "Waiting for others to finish their tasks.<br>";
      return true;
    }
    return false;
  }
  function fakeProgress() {
    let progress = document.getElementById('progress').value;
    const maxFakeProgress = 0.95;
    if (progress < maxFakeProgress) {
      progress = progress + (1 - progress) * .1;
      document.getElementById('progress').value = progress;
    }
  }
  async function getProgress() {
    const url = document.getElementById('url').value;
    const api_key = apikeyInput.value;
    let res = await fetch(`${url}/sdapi/v1/progress?skip_current_image=true`, { method: 'GET', headers: { Authorization: api_key } })
    return await res.json();
  }
  async function setProgress() {
    let data = await getProgress();
    document.getElementById('progress').value = data.progress;
    if (data.state.job_count == 0) {
      clearInterval(realProgressInterval);
      clearInterval(fakeProgressInterval);
      document.getElementById('progress').value = 1;
    }
    return data;
  }
  function setUiAvailiability(selected_nodes_count = 0) {
    serverLogLabel.innerHTML = "";
    if (!sdServerAvailable) { txt2imgButton.disabled = true; serverLogLabel.innerHTML += "Not connected to any server yet<br>Try pressing the connect to demo server button<br>" } else txt2imgButton.disabled = false;
    if (!figmaAvailable) { serverLogLabel.innerHTML += "Can't find figma extension<br>" }
    if (!autoMaskAvailable) { autoMaskButton.disabled = true; serverLogLabel.innerHTML += "Can't find auto mask extension<br>" }
    if (!promptMaskAvailable) { promptMaskButton.disabled = true; serverLogLabel.innerHTML += "Can't find prompt mask extension<br>" }
    if (!controlNetAvailable) { renderSketchButton.disabled = true; serverLogLabel.innerHTML += "Can't find control net extension<br>" }

    if (selected_nodes_count == 0) {
      autoMaskButton.disabled = true;
      promptMaskButton.disabled = true;
      renderSketchButton.disabled = true;
      image_2_vectorsButton.disabled = true;
      findItemsButton.disabled = true;
    } else if (selected_nodes_count > 0) {
      image_2_vectorsButton.disabled = false;
      findItemsButton.disabled = false;
      if (autoMaskAvailable) autoMaskButton.disabled = false;
      if (promptMaskAvailable) promptMaskButton.disabled = false;
      if (controlNetAvailable) renderSketchButton.disabled = false;
    }
    if (generatingImage) {
      txt2imgButton.disabled = true;
      renderSketchButton.disabled = true;
    }
  }
  async function apiHaveResponse(url) {
    try {
      let res = await fetch(url)
      if (res.status === 200) {
        return true;
      } else {
        return false;
      }
    } catch (e) {
      return false;
    }
  }
  async function checkAvailibility() {
    const url = urlInput.value;
    const api_key = apikeyInput.value;
    connectionStatusLabel.innerHTML = "Checking connection...";
    sdServerAvailable = await apiHaveResponse(`${url}/app_id/`, { method: 'GET', headers: { Authorization: api_key } });
    autoMaskAvailable = await apiHaveResponse(`${url}/auto_mask/status`, { method: 'GET', headers: { Authorization: api_key } });
    figmaAvailable = await apiHaveResponse(`${url}/figma/status`, { method: 'GET', headers: { Authorization: api_key } });
    promptMaskAvailable = await apiHaveResponse(`${url}/prompt_mask/status`, { method: 'GET', headers: { Authorization: api_key } });
    controlNetAvailable = await apiHaveResponse(`${url}/controlnet/version`, { method: 'GET', headers: { Authorization: api_key } });
    setUiAvailiability(selected_nodes_count);
    connectionStatusLabel.innerHTML = "";
    parent.postMessage({ pluginMessage: { type: 'check_availibility', original_task: "check_availibility", url } }, '*');
  }
  function getSeed() {
    function getRandomFullRangeInt() {
      const min = BigInt(0);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      const range = max - min + BigInt(1);
      const randomBigInt = BigInt(Math.floor(Math.random() * Number(range)));
      return String(min + randomBigInt);
    }
    let seed = seedInput.value;
    if (seed == "") seed = getRandomFullRangeInt();
    return seed;
  }
  function debounce(func, delay) {
    let timeoutId;
    return function () {
      const context = this;
      const args = arguments;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        func.apply(context, args);
      }, delay);
    }
  }
  function debounceAsync(func, delay) {
    let timeout;
    return async function (...args) {
      return new Promise(async (resolve, reject) => {
        if (timeout) {
          clearTimeout(timeout);
        }
        timeout = setTimeout(async () => {
          try {
            const result = await func.apply(this, args);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        }, delay);
      });
    };
  }
  function runEvery(func, ticks) {
    let lastExecuted = null;
    let lastResult = null;

    return async function (...args) {
      const now = Date.now();

      if (!lastExecuted || now - lastExecuted > ticks) {
        lastExecuted = now;
        const result = await func.apply(this, args);
        lastResult = result;
        return result;
      } else {
        return lastResult;
      }
    };
  }
</script>