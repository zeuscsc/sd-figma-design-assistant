<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stable Diffusion Design Assistant</title>
  <style>
    body {
      font: 1em sans-serif;
    }

    h6 {
      color: red;
    }

    h5 {
      color: blue;
    }

    input {
      width: 100%;
      height: 40px;
    }

    .radio {
      width: 20px;
      height: 20px;
    }

    .checkbox {
      width: 20px;
      height: 20px;
    }

    .size {
      width: 100%;
    }

    table {
      width: 100%;
      text-align: center;
      vertical-align: middle;
    }

    .sizeSliders td,
    table th {
      width: 50%;
      text-align: center;
      vertical-align: middle;
    }

    .stylesRadio td,
    table th {
      width: 33%;
      text-align: left;
      vertical-align: left;
    }

    img {
      width: 100%;
    }

    .row {
      display: flex;
      flex-direction: row;
      justify-content: space-evenly;
    }

    progress {
      width: 100%;
    }
  </style>
</head>

<body>
  <p>Stable Diffusion Hosting URL:</p>
  <input id="url" type="text" placeholder="Enter a Stable Diffusion Hosting URL" />
  <div class="row">
    <input type="button" id="connect2local" value="Connect to Local&#13;&#10;Stable Diffusion"
      onclick="document.getElementById('url').value='http://localhost:7860';checkAvailibility()" />
    <input type="button" id="connect2offical" value="Connect to Offical&#13;&#10;Stable Diffusion"
      onclick="document.getElementById('url').value='https://sd.zeuschiu.com';checkAvailibility()" />
  </div>
  <h6 id="server_log"></h6>
  <h5 id="connection_status"></h5>
  <p>Prompt:</p>
  <input id="prompt" type="text" placeholder="Enter a prompt" />
  <input type="checkbox" class="checkbox" id="keep_generating_checkbox"><label for="keep_generating_checkbox">Keep
    Generating</label>
  <table class="sizeSliders">
    <tr>
      <th>Width</th>
      <th>Height</th>
    </tr>
    <tr>
      <td><input type="text" class="size" id="width" value="512"></td>
      <td><input type="text" class="size" id="height" value="512"></td>
    </tr>
    <tr>
      <td><input type="range" class="size" id="width_slider" min="512" max="960" value="512" step="64"
          oninput="width_slider.value=parseInt(width_slider.value);document.getElementById('width').value=width_slider.value">
      </td>
      <td><input type="range" class="size" id="height_slider" min="512" max="960" value="512" step="64"
          oninput="height_slider.value=parseInt(height_slider.value);document.getElementById('height').value=height_slider.value">
      </td>
    </tr>
  </table>
  <table class="stylesRadio">
    <tr>
      <th></th>
      <th></th>
      <th></th>
    </tr>
    <tr>
      <td><input type="radio" class="radio" name="style" value="default" checked><label for="style">Default</label></td>
      <td><input type="radio" class="radio" name="style" value="photo"><label for="style">Photo</label></td>
      <td><input type="radio" class="radio" name="style" value="icon"><label for="style">Icon</label></td>
    </tr>
    <tr>
      <td><input type="radio" class="radio" name="style" value="sticker"><label for="style">Sticker</label></td>
      <td><input type="radio" class="radio" name="style" value="anime"><label for="style">Anime</label></td>
      <td><input type="radio" class="radio" name="style" value="studio"><label for="style">Studio</label></td>
    </tr>
  </table>
  <div class="">
    <p></p>
    <label id="vectors_guidance_label" for="vectors_guidance_slider">Vectors Guidance: Normal</label>
    <input type="range" id="vectors_guidance_slider" min="0" max="2" value="1" step="0.5" list="vectors_guidance_data">
    <datalist id="vectors_guidance_data">
      <option value="0" label="None">
      <option value="0.5" label="Free">
      <option value="1" label="Normal">
      <option value="1.5" label="Details">
      <option value="2" label="Same">
    </datalist>
  </div>
  <div class="row">
    <input type="button" id="txt2img" disabled value="Text 2 Image" />
  </div>
  <div class="row">
    <input type="button" id="auto_mask" disabled value="Auto&#13;&#10;Background Removal" />
    <input type="button" id="prompt_mask" disabled value="Prompt&#13;&#10;Background Removal" />
  </div>
  <div class="row">
    <input type="button" id="image_2_vectors" disabled value="Image 2 Vectors" />
    <input type="button" id="vectors_2_image" disabled value="Render Sketch" />
  </div>
  <div class="row">
    <input type="button" id="find_items" disabled value="Find Items" />
  </div>
  <progress id="progress" value="0" max="1"></progress>
</body>

</html>
<script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simplify-js@1.2.4/simplify.min.js"></script>
<script>
  const urlInput = document.getElementById('url');
  const txt2imgButton = document.getElementById('txt2img');
  const renderSketchButton = document.getElementById('vectors_2_image');
  const autoMaskButton = document.getElementById('auto_mask');
  const promptMaskButton = document.getElementById('prompt_mask');
  const image_2_vectorsButton = document.getElementById('image_2_vectors');
  const findItemsButton = document.getElementById('find_items');
  const serverLogLabel = document.getElementById('server_log');
  const connectionStatusLabel = document.getElementById('connection_status');
  const keepGeneratingCheckbox = document.getElementById('keep_generating_checkbox');
  let progressInterval = null;
  let sdServerAvailable = false;
  let autoMaskAvailable = false;
  let promptMaskAvailable = false;
  let controlNetAvailable = false;
  let generatingImage = false;
  let selected_nodes_count = 0;
  const checkAvailibilityDebouncedHandleInputValueChange = debounce(checkAvailibility, 500);
  urlInput.addEventListener('input', checkAvailibilityDebouncedHandleInputValueChange);
  document.getElementById('txt2img').onclick = (e) => {
    txt2img();
  }
  document.querySelector("#image_2_vectors").addEventListener("click", (e) => {
    parent.postMessage({ pluginMessage: { type: 'get_selected_image', original_task: "image_2_vectors" } }, '*')
  });
  document.querySelector("#auto_mask").addEventListener("click", (e) => {
    parent.postMessage({ pluginMessage: { type: 'get_selected_image', original_task: "auto_mask" } }, '*')
  });
  document.querySelector("#prompt_mask").addEventListener("click", (e) => {
    parent.postMessage({ pluginMessage: { type: 'get_selected_image', original_task: "prompt_mask" } }, '*')
  });
  document.querySelector("#vectors_2_image").addEventListener("click", (e) => {
    vectors_2_image();
  });
  document.querySelector("#find_items").addEventListener("click", (e) => {
    parent.postMessage({ pluginMessage: { type: 'find_items', original_task: "find_items" } }, '*')
  });
  document.querySelector("#vectors_guidance_slider").addEventListener("input", (e) => {
    switch (e.target.value) {
      case "0":
        document.querySelector("#vectors_guidance_label").textContent = `Vectors Guidance: None`;
        break;
      case "0.5":
        document.querySelector("#vectors_guidance_label").textContent = `Vectors Guidance: Free`;
        break;
      case "1":
        document.querySelector("#vectors_guidance_label").textContent = `Vectors Guidance: Normal`;
        break;
      case "1.5":
        document.querySelector("#vectors_guidance_label").textContent = `Vectors Guidance: Details`;
        break;
      case "2":
        document.querySelector("#vectors_guidance_label").textContent = `Vectors Guidance: Same`;
        break;
    }
  });

  window.addEventListener('message', event => {
    if (event.data && event.data.pluginMessage.type === 'api_results') {
      on_api_results(event.data.pluginMessage.original_task, event.data.pluginMessage.data);
    }
    if (event.data && event.data.pluginMessage.type === 'done') {
      on_done(event.data.pluginMessage.original_task);
    }
    if (event.data && event.data.pluginMessage.type === 'image_selected') {
      on_selected_image(event.data.pluginMessage.original_task, event.data.pluginMessage.data);
    }
    if (event.data && event.data.pluginMessage.type === 'sync_img2img_ui') {
      setUiAvailiability(event.data.pluginMessage.selected_nodes_count);
    }
    if (event.data && event.data.pluginMessage.type === 'on_initialized') {
      checkAvailibility();
      selected_nodes_count = event.data.pluginMessage.selected_nodes_count;
    }
  });

  window.addEventListener("keydown", function (event) {
    if (event.key === "Escape") {
      parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*')
    }
    if (event.key === "Enter") {
      vectors_2_image()
    }
    if (event.shiftKey && event.key === "Enter") {
      txt2img()
    }
  });

  async function on_done(original_task) {
    txt2imgButton.disabled = false;
    renderSketchButton.disabled = false;
    generatingImage = false;
    switch (original_task) {
      case "txt2img":
        document.getElementById('progress').value = 1;
        if (keepGeneratingCheckbox.checked) txt2img();
        break;
      case "vectors_2_image":
        document.getElementById('progress').value = 1;
        if (keepGeneratingCheckbox.checked) vectors_2_image();
        break;
    }
  }
  async function on_api_results(original_task, data) {
    let byte_array = null;
    switch (original_task) {
      case "prompt_mask":
      case "txt2img":
      case "auto_mask":
      case "vectors_2_image":
        byte_array = _base64ToUint8Array(data);
        parent.postMessage({ pluginMessage: { type: 'create_image_node', original_task, byte_array } }, '*')
        break;
    }
  }
  async function on_selected_image(original_task, data) {
    switch (original_task) {
      case "image_2_vectors":
        image_2_vectors(data);
        break;
      case "auto_mask":
      case "prompt_mask":
      case "vectors_2_image":
        image2image(data, original_task);
        break;
    }
  }
  function image2image(data, original_task) {
    var base64 = btoa(new Uint8Array(data).reduce((data, byte) => data + String.fromCharCode(byte), ''),);
    const style = getSelectedStyle()
    const textbox_prompt = document.getElementById('prompt');
    const width_input = document.getElementById('width');
    const height_input = document.getElementById('height');
    const url = document.getElementById('url').value;
    const vectors_guidance = document.getElementById('vectors_guidance_slider').value;
    let prompt = textbox_prompt.value;
    let width = width_input.value;
    let height = height_input.value;
    const pluginMessage = { type: original_task, imageUrl: base64, prompt, width, height, style, url, vectors_guidance }
    parent.postMessage({ pluginMessage }, '*')
  }
  function image_2_vectors(data) {
    let binary = '';
    data.forEach(byte => binary += String.fromCharCode(byte));
    const base64String = btoa(binary);
    const url = `data:image/png;base64,${base64String}`
    const img = document.createElement('img');
    img.src = url;
    ImageTracer.imageToSVG(url, function (svgstr) {
      const width_input = document.getElementById('width');
      const height_input = document.getElementById('height');
      let width = width_input.value;
      let height = height_input.value;
      console.log(svgstr)
      parent.postMessage({ pluginMessage: { type: 'create_node_from_svg', svgstr, width, height } }, '*')
    });

  }
  function txt2img() {
    if (txt2imgButton.disabled) {
      return;
    }
    const style = getSelectedStyle()
    const textbox_prompt = document.getElementById('prompt');
    const width_input = document.getElementById('width');
    const height_input = document.getElementById('height');
    const url = document.getElementById('url').value;
    let prompt = textbox_prompt.value;
    let width = width_input.value;
    let height = height_input.value;
    parent.postMessage({ pluginMessage: { type: 'txt2img', prompt, width, height, style, url } }, '*')
    generatingImage = true;
    setUiAvailiability();
    progressInterval = setInterval(getProgress, 1000);
  }
  function vectors_2_image() {
    if (renderSketchButton.disabled) {
      return;
    }
    parent.postMessage({ pluginMessage: { type: 'get_selected_image', original_task: "vectors_2_image" } }, '*');
    generatingImage = true;
    setUiAvailiability();
    progressInterval = setInterval(getProgress, 1000);
  }
  function _base64ToUint8Array(base64) {
    var binary_string = window.atob(base64);
    var len = binary_string.length;
    var bytes = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
      bytes[i] = binary_string.charCodeAt(i);
    }
    return new Uint8Array(bytes.buffer);
  }
  function getSelectedStyle() {
    return document.querySelector('input[name="style"]:checked').value;
  }
  async function getProgress() {
    const url = document.getElementById('url').value;
    let res = await fetch(`${url}/sdapi/v1/progress`)
    let data = await res.json();
    document.getElementById('progress').value = data.progress;
    if (data.state.job_count == 0) {
      clearInterval(progressInterval);
      document.getElementById('progress').value = 1;
    }
  }
  function setUiAvailiability(selected_nodes_count = 0) {
    serverLogLabel.innerHTML = "";
    if (!sdServerAvailable) { txt2imgButton.disabled = true; serverLogLabel.innerHTML += "Can't connect to server<br>" } else txt2imgButton.disabled = false;
    if (!autoMaskAvailable) { autoMaskButton.disabled = true; serverLogLabel.innerHTML += "Can't find auto mask extension<br>" }
    if (!promptMaskAvailable) { promptMaskButton.disabled = true; serverLogLabel.innerHTML += "Can't find prompt mask extension<br>" }
    if (!controlNetAvailable) { renderSketchButton.disabled = true; serverLogLabel.innerHTML += "Can't find control net extension<br>" }

    if (selected_nodes_count == 0) {
      autoMaskButton.disabled = true;
      promptMaskButton.disabled = true;
      renderSketchButton.disabled = true;
      image_2_vectorsButton.disabled = true;
      findItemsButton.disabled = true;
    } else if (selected_nodes_count > 0) {
      image_2_vectorsButton.disabled = false;
      findItemsButton.disabled = false;
      if (autoMaskAvailable) autoMaskButton.disabled = false;
      if (promptMaskAvailable) promptMaskButton.disabled = false;
      if (controlNetAvailable) renderSketchButton.disabled = false;
    }
    if (generatingImage) {
      txt2imgButton.disabled = true;
      renderSketchButton.disabled = true;
    }
  }
  async function login() {
    const url = document.getElementById('url').value;
    let res = await fetch(`${url}/sdapi/v1/login`, {
      method: "POST",
      body: JSON.stringify({
        username: document.getElementById('username').value,
        password: document.getElementById('password').value
      })
    })
    let data = await res.json();
    if (data.status == "ok") {
    }
  }
  async function apiHaveResponse(url) {
    try {
      let res = await fetch(url)
      if (res.status === 200) {
        return true;
      } else {
        return false;
      }
    } catch (e) {
      // console.log(e)
      return false;
    }
  }
  async function checkAvailibility() {
    const url = urlInput.value;
    connectionStatusLabel.innerHTML = "Checking connection...";
    sdServerAvailable = await apiHaveResponse(`${url}/app_id/`);
    autoMaskAvailable = await apiHaveResponse(`${url}/auto_mask/status`);
    promptMaskAvailable = await apiHaveResponse(`${url}/prompt_mask/status`);
    controlNetAvailable = await apiHaveResponse(`${url}/controlnet/version`);
    setUiAvailiability(selected_nodes_count);
    connectionStatusLabel.innerHTML = "";
  }
  function debounce(func, delay) {
    let timeoutId;
    return function () {
      const context = this;
      const args = arguments;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        func.apply(context, args);
      }, delay);
    }
  }
</script>